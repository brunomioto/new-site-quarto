{
  "hash": "91b0549929911f341d314c440847dda9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Decifrando gráficos #2\"\ndescription: \"Do Jornal para o R\"\nauthor: \"Bruno Mioto\"\ndate: \"2025-03-17\"\nimage: cover.png\ncategories: [\"tutorial\",\"dataviz\",\"ggplot2\"]\nopen-graph:\n  description: \"Do Jornal para o R\"\n  image: cover.png\ntwitter-card:\n  description: \"Do Jornal para o R\"\n  image: cover.png\n  card-style: summary_large_image\nformat:\n  html:\n    code-link: true\n    fig-width: 5\n    fig-height: 2\n    fig-dpi: 600\nexecute:\n  warning: false\ndraft: true\n---\n\n\n\n\n\n![](cover.png)\n\n## Como isso foi feito?\n\nTodo dia vemos gráficos nos jornais, mas nem sempre sabemos como eles foram feitos. De onde vieram os **dados**? Como foram **tratados**? E será que dá para **recriá-los** usando o R?\n\nNesta série, pegamos gráficos publicados nos principais **jornais** e recriamos do zero usando **R, tidyverse e ggplot2**. Vou mostrar como encontrar os dados, organizá-los e gerar visualizações que chegam o mais próximo possível do original – tudo de forma transparente e didática. Sim! Vamos fazer e aprender juntos!\n\nE tem mais: **todo o código e dados utilizados estarão disponíveis e comentados (clique nos números abaixo de cada conjunto de código!)**. E por estarmos trabalhando com uma **linguagem de programação**, todos vão obter o mesmo resultado ao final do script.\n\nAcompanhe a série e veja como transformar dados brutos em visualizações incríveis!\n\n## Post anterior\n\nQuer ver o post anterior? Acesse abaixo\n\n\n\n\n\n```{=html}\n<div class=\"card-grid\">\n\n\n  <a href=\"https://www.brunomioto.com/posts/decifrando_graficos/1_nexo/\" class=\"image-card\" target=\"_blank\" rel=\"noopener noreferrer\">\n    <img src=\"https://www.brunomioto.com/posts/decifrando_graficos/1_nexo/cover.png\" class=\"card-image\">\n    <div class=\"card-title\">Decifrando gráficos #1</div>\n  </a>\n\n</div>\n\n<style>\n.card-grid {\n  display: grid;\n  grid-template-columns: repeat(1, 1fr); /* 2 colunas no desktop */\n  gap: 20px; /* Espaço entre os cards */\n}\n\n.image-card {\n  display: flex;\n  flex-direction: column;\n  text-decoration: none;\n  color: black; /* ou qualquer outra cor */\n  border: 1px solid #ddd; /* Borda opcional */\n  border-radius: 5px; /* Borda arredondada opcional */\n  overflow: hidden; /* Garante que a imagem não vaze do card */\n}\n\n.card-image {\n  width: 100%;\n  height: auto;\n  display: block;\n}\n\n.card-title {\n  padding: 10px;\n  text-align: center;\n}\n\n/* Media query para dispositivos móveis */\n@media (max-width: 768px) {\n  .card-grid {\n    grid-template-columns: 1fr; /* 1 coluna no celular */\n  }\n}\n</style>\n\n```\n\n\n\n\n\n## #2 - Pirâmide etária indígena (Folha de São Paulo)\n\nDessa vez vamos analisar um gráfico publicado pela **Folha de São Paulo** com dados do Censo 2022: [População indígena cresce no Norte, mas envelhece ao redor das cidades](https://www1.folha.uol.com.br/cotidiano/2024/05/populacao-indigena-cresce-no-norte-mas-envelhece-ao-redor-das-cidades.shtml)\n\n![](./figures/grafico_folha.png)\n\nEu particularmente acho muito legal visualizar pirâmides etárias, como essa que fiz com o pessoal da [Base dos Dados](https://medium.com/basedosdados/analisando-dados-de-vacinação-contra-covid-19-com-a-bd-49fe3db8c7f4). E o mais legal dessa vez é que vamos fazer a visualização completa!\n\n### Obtendo os dados\n\nTodos os dados do Censo 2022 estão disponíveis na aba de Downloads do portal: [https://censo2022.ibge.gov.br/panorama/downloads.html](https://censo2022.ibge.gov.br/panorama/downloads.html?localidade=BR). Lá vamos acessar os resultados [**Quilombolas e Indígenas, por sexo e idade, segundo recortes territoriais específicos - Resultados do universo**](https://www.ibge.gov.br/estatisticas/sociais/populacao/22827-censo-demografico-2022.html?edicao=39859&t=resultados) e então selecionamos [**População indígena, por localização do domicílio, grupos de idade e sexo**](https://sidra.ibge.gov.br/Tabela/8175).\n\nLogo nessa página vemos que os dados estão disponíveis através do **SIDRA** (Sistema IBGE de Recuperação Automática), que é basicamente uma plataforma que concentra **todos** os dados do IBGE! E o melhor: podemos acessar diretamente do R com o pacote [{sidrar}](https://github.com/rpradosiqueira/sidrar/)!\n\nAntes de tudo, vamos carregar os pacotes necessários\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sidrar) #baixar dados IBGE\nlibrary(janitor) #limpeza dos dados\nlibrary(dplyr) #manipulação dos dados\nlibrary(stringr) #trabalhar com strings/texto\n# library(tidyr) #tratamento dos dados\nlibrary(ggplot2) #gráficos\n```\n:::\n\n\n\n\n\nAgora só precisamos do número da tabela disponível no site (que é 8175) e rodar o código abaixo:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages(\"sidrar\")\nlibrary(sidrar)\n\npop_ind <- sidrar::get_sidra(8175)\n```\n:::\n\n\n\n\n\nPronto, fácil assim já temos os dados do Censo para este gráfico!\n\n<!-- ::: {.callout-note collapse=\"true\"} -->\n<!-- ## Baixar direto do site -->\n<!-- NÃO FUNCIONA -->\n<!-- Se você achar mais fácil, também pode baixar os dados direto do [site](https://sidra.ibge.gov.br/Tabela/8175). Selecione a variável `Pessoas indígenas (Pessoas)`, selecione todas opções para `Idade`, `Sexo`, `Localização do domicílio`, o ano 2022 para `Ano` e Brasil para `Unidade Territorial`. Agora é só clicar em Download e salvar com o formato **CSV (US)** na pasta `data` no diretório de trabalho. -->\n\n<!-- Agora vamos importar os dados -->\n\n<!-- ```{r} -->\n<!-- library(readr) -->\n\n<!-- pop_ind <- readr::read_csv(\"./data/tabela8175.csv\",skip = 1) -->\n<!-- ``` -->\n<!-- ::: -->\n\n### Trabalhando com os dados\n\nPois é, nossos dados sempre têm os nomes das variáveis com letras maiúsculas, espaços e acentos. Vamos padronizar para `snake_case`com o pacote {janitor} e também selecionar apenas as variáveis necessárias para este gráficos. Vamos salvando cada passo em um novo objeto para ficar mais fácil de acompanhar.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_ind2 <- pop_ind |> \n  janitor::clean_names() |> \n  dplyr::select(\n    variavel, \n    ano, \n    idade,\n    sexo, \n    localizacao_do_domicilio,\n    valor\n    )\n```\n:::\n\n\n\n\n\nMas veja que temos um valor **`Total`** em `idade`, `sexo` e `localizacao_do_domicilio`. Não vamos precisar dos totais, então podemso removê-los,\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_ind3 <- pop_ind2 |> \n  dplyr::filter(\n    idade != \"Total\",\n    sexo != \"Total\",\n    localizacao_do_domicilio != \"Total\"\n  )\n```\n:::\n\n\n\n\n\nNessa tabela, temos as idades individuais, ou agrupadas a cada 5 anos. Vamos selecionar apenas as linhas com as idades agrupadas.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_ind4 <- pop_ind3 |> \n  filter(\n      idade %in% c(\n        \"0 a 4 anos\",\n        \"5 a 9 anos\",\n        \"10 a 14 anos\",\n        \"15 a 19 anos\",\n        \"20 a 24 anos\",\n        \"25 a 29 anos\",\n        \"30 a 34 anos\",\n        \"35 a 39 anos\",\n        \"40 a 44 anos\",\n        \"45 a 49 anos\",\n        \"50 a 54 anos\",\n        \"55 a 59 anos\",\n        \"60 a 64 anos\",\n        \"65 a 69 anos\",\n        \"70 a 74 anos\",\n        \"75 a 79 anos\",\n        \"80 a 84 anos\",\n        \"85 a 89 anos\",\n        \"90 a 94 anos\",\n        \"95 a 99 anos\",\n        \"100 anos ou mais\"\n      )\n  )\n```\n:::\n\n\n\n\n\n::: {.callout-tip collapse=\"true\"}\n## Preguiça de escrever tudo\n\nSe você não quer ficar digitando tudo (ou não quer pedir para o chatGPT escrever para você), é possível selecionar as linhas usando **expressões regulares**! Sim, elas parecem bruxaria, mas tem uma [colinha](https://rstudio.github.io/cheatsheets/translations/portuguese/strings_pt_br.pdf) que ajuda muito!\n\nO segredo é encontrar padrões! Veja que as categorias são basicamente **número+ a +número**, e o \"100 anos ou mais\" colocamos na mão. Vamos lá!\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_ind4 <- pop_ind3 |> \n  filter(\n    stringr::str_detect( # <1>\n      idade, # <2>\n      \"[:digit:] a [:digit:]|100 anos ou mais\") # <3>\n    )\n```\n:::\n\n\n\n\n1. Detecta a ocorrência de expressões regulares\n2. Na variável `idade`\n3. E a expressão é: **[número] a [número] OU \"100 anos ou mais\"**\n\nBem mais simples!\n:::\n\nAgora para deixar igualzinho ao gráfico, vamos remover as palavras \" anos\" e transformar \"100 anos ou mais\" em \"100+\"\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_ind5 <- pop_ind4 |> \n  mutate(\n    idade2 = stringr::str_remove( # <1>\n      idade, # <2>\n      \" anos.*\" # <3>\n      ),\n    idade2 = ifelse(idade2 == 100, \"100+\", idade2) # <4>\n  )\n```\n:::\n\n\n\n\n1. Remove a ocorrência de expressões regulares\n2. Na variável `idade`\n3. E a expressão é: **[espaço]anos(e tudo que vier depois)**\n4. Se `idade2` for igual a 100, transformar em \"100+\", se não for ignora\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_ind6 <- pop_ind5 |> \n  group_by(localizacao_do_domicilio) |> \n  add_count(name = \"total\", wt = valor) |> \n  ungroup() |> \n  mutate(prop = valor/total)\n```\n:::\n\n\n\n\n\nAgora vamos fazer um truque e multiplicar os prop para homens por -1, assim eles ficam do lado esquerdo da pirâmide.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_ind7 <- pop_ind6 |> \n  mutate(\n    prop = ifelse(sexo == \"Homens\", prop*-1, prop)\n  )\n```\n:::\n\n\n\n\n\nVamos ver se os dados estão prontos?\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_ind7 |> \n  ggplot(aes(x = prop, y = idade2, fill = sexo))+\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=3000}\n:::\n:::\n\n\n\n\n\nVeja que as categoias de idade estão seguindo uma ordem alfabética, mas queremos que sigam a ordem da pirâmide etária. Vamos ordenar a variável `idade2` de acordo com a ordem que queremos.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_ind8 <- pop_ind7 |> \n  mutate(idade2 = forcats::fct_inorder(idade2))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npop_ind8 |> \n  ggplot(aes(x = prop, y = idade2, fill = sexo))+\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=3000}\n:::\n:::\n\n\n\n\n\nPronto! Temos os dados prontos para o gráfico! Agora vamos para a parte mais legal!\n\n### Criando o gráfico\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_ind8 |> \n  ggplot(aes(x = prop, y = idade2, fill = sexo))+\n  geom_col(\n    data = ~filter(., \n                   localizacao_do_domicilio == \"Em terras indígenas\"))+\n  geom_col(\n    data = ~filter(., \n                   localizacao_do_domicilio == \"Fora de terras indígenas\"),\n    fill = NA,\n    color = \"black\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=3000}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npop_ind8 |> \n  ggplot(aes(x = prop, y = idade2, fill = sexo, color = sexo))+\n  geom_col(\n    data = ~filter(., \n                   localizacao_do_domicilio == \"Em terras indígenas\"),\n    show.legend = FALSE,\n    # alpha = 0.3,\n    color = NA)+\n  geom_col(\n    data = ~filter(., \n                   localizacao_do_domicilio == \"Fora de terras indígenas\"),\n    show.legend = FALSE,\n    fill = NA)+\n  scale_x_continuous(\n    breaks = seq(-0.08,0.08,0.02),\n    labels = c(\"8%\",\"6\",\"4\",\"2\",\"0\",\"2\",\"4\",\"6\",\"8%\")\n  )+\n  scale_fill_manual(\n    values = c(\n      \"Mulheres\" = \"#b3abce\",\n      \"Homens\" = \"#a5d4cf\"\n    )\n  )+\n  scale_color_manual(\n    values = c(\n      \"Mulheres\" = \"#420e44\",\n      \"Homens\" = \"#076e56\"\n    )\n  )+\n  theme_minimal()+\n  theme(\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(color = \"black\"),\n    axis.ticks.x = element_line(color = \"#ebebeb\")\n  )+\n  coord_cartesian(\n    xlim = c(-0.08,0.08)\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=3000}\n:::\n:::\n\n\n\n\n\n<!-- Mas veja que precisamos quebrar a coluna `seasons` para cada valor ficar em uma linha, obtendo um formato **tidy**, que utilizaremos no **ggplot2** mais pra frente. Para isso vamos usar a função `tidyr::separate_longer_delim()` que nos permite separar uma string por algum delimitador (nesse caso `, `). E vamos também remover os colchetes `[` ou `]` que ficarem perdidos utilizando o pacote {stringr} e transformar essa variável em numérica. -->\n\n<!-- ```{r} -->\n<!-- pilotos_br4 <- pilotos_br3 |>  -->\n<!--   tidyr::separate_longer_delim( # <1> -->\n<!--     cols = c(seasons), # <1> -->\n<!--     delim = \", \") |>  # <1> -->\n<!--   dplyr::mutate( # <2> -->\n<!--     seasons = stringr::str_remove_all(seasons, \"\\\\[|\\\\]\"), # <2> -->\n<!--     seasons = as.numeric(seasons) # <2> -->\n<!--     )  # <2> -->\n<!-- ``` -->\n<!-- 1. Separa os valores na coluna `seasons` em múltiplas linhas, usando a vírgula seguida de espaço como delimitador. -->\n<!-- 2. Remove os colchetes `[` ou `]` e transforma a variável `seasons` em numérica. -->\n\n<!-- Agora vamos utilizar este dataset para criar o `pilotos_campeoes`. Vamos usar novamente o `tidyr::separate_longer_delim()`, mas dessa vez com a variável `championship_years`. -->\n<!-- Isso vai gerar linhas duplicadas, pois a função busca criar todas combinações entre as linhas. Como aqui queremos apenas os campeões nos respectivos anos, vamos filtrar as temporadas (`seasons`) que são iguais às temporadas vitoriosas (`championship_years`). -->\n<!-- Por fim, vamos criar uma coluna dizendo que eles foram campeões neste ano -->\n\n<!-- ```{r} -->\n<!-- pilotos_campeoes <- pilotos_br4 |> -->\n<!--   tidyr::separate_longer_delim( # <1> -->\n<!--     cols = c(championship_years), # <1> -->\n<!--     delim = \", \") |> # <1> -->\n<!--   dplyr::mutate( # <2> -->\n<!--     championship_years = stringr::str_remove_all( # <2> -->\n<!--       championship_years, # <2> -->\n<!--       \"\\\\[|\\\\]\")) |> # <2> -->\n<!--   filter(seasons == championship_years) |>  # <3> -->\n<!--   mutate( # <4> -->\n<!--     campeao = TRUE # <4> -->\n<!--   ) # <4> -->\n<!-- ``` -->\n<!-- 1. Separa os valores na coluna `championship_years` em múltiplas linhas, usando a vírgula seguida de espaço como delimitador. -->\n<!-- 2. Remove os colchetes `[` ou `]` e transforma a variável `seasons` em numérica. -->\n<!-- 3. Filtra `seasons` iguais à `championship_years`. -->\n<!-- 4. Cria uma coluna `campeao` com valor `TRUE` para estes pilotos. -->\n\n<!-- Agora só precisamos combinar o dataset `pilotos_campeoes` com o `pilotos_br4` utilizando o `left_join()`. Aqui vamos falar para utilizar as colunas `driver` e `seasons` como guias do **join** -->\n\n<!-- ```{r} -->\n<!-- pilotos_br5 <- pilotos_br4 |>  -->\n<!--   dplyr::left_join( -->\n<!--     pilotos_campeoes, -->\n<!--     by = c(\"driver\", \"seasons\") # <2> -->\n<!--     ) -->\n<!-- ``` -->\n<!-- 1. Define quais variávels serão combinadas de ambos os datasets. -->\n\n<!-- Pronto! Temos toda a informação que precisamos. Vamos aos gráficos! -->\n\n<!-- ### Criando o gráfico -->\n\n<!-- Logo de cara, vemos que o gráfico do **Nexo** é um *tile plot*, em que utilizamos a função `geom_tile()`. -->\n\n<!-- Para isso, precisamos contar o número de pilotos em cada ano, já que o eixo Y apresenta a soma de pilotos. Para isso podemos agrupar nosso dataset por temporada (`group_by()`) e contar o numero de linhas/pilotos (`row_number()`) -->\n\n<!-- ```{r} -->\n<!-- soma_pilotos <- pilotos_br5 |>  -->\n<!--   dplyr::group_by(seasons) |> # <1> -->\n<!--   dplyr::mutate(soma = dplyr::row_number()) # <2> -->\n<!-- ``` -->\n<!-- 1. Agrupa os dados por temporada (`seasons`)  -->\n<!-- 2. Conta o número de linhas (nesse caso, pilotos) em cada grupo -->\n\n<!-- Agora vamos plotar! Lembre-se que precisamos utilizar cores de preenchimento diferentes para campeões e também para a temporada atual! -->\n\n<!-- ```{r} -->\n<!-- soma_pilotos |>                            # <1> -->\n<!--   ggplot(aes(x = seasons, y = soma))+      # <2> -->\n<!--   geom_tile(                                # <3> -->\n<!--     aes(fill = dplyr::case_when(            # <4> -->\n<!--       campeao == TRUE ~ \"campeão\",          # <4> -->\n<!--       seasons == 2025 ~ \"atual\",            # <4> -->\n<!--       TRUE ~ \"normal\"                        # <4> -->\n<!--     ))                                      # <4> -->\n<!--   )+                                        # <3> -->\n<!--   theme(                                     # <5> -->\n<!--     legend.position = \"none\"                 # <5> -->\n<!--   )                                          # <5> -->\n\n<!-- ``` -->\n<!-- 1. Pegamos `soma_pilotos` e passamos adiante com o pipe. -->\n<!-- 2. Criamos um gráfico com `ggplot()`, onde `seasons` define o eixo X e `soma` define o eixo Y. -->\n<!-- 3. Adicionamos `geom_tile()`, que cria um mosaico de retângulos para representar os valores. -->\n<!-- 4. Definimos a cor de preenchimento com `case_when()`, categorizando os tiles como \"campeão\", \"atual\" ou \"normal\". -->\n<!-- 5. Ajustamos o tema para remover a legenda `(legend.position = \"none\")`, deixando o gráfico mais limpo. -->\n\n<!-- Quase! Veja que os campeões não estão na base, como na figura original. Para isso precisamos ordenar (`arrange()`) o dataset para que os campeões apareçam primeiro na contagem de linhas. Vamos tentar novamente! -->\n\n\n<!-- ```{r} -->\n<!-- soma_pilotos <- pilotos_br5 |>  -->\n<!--   dplyr::group_by(seasons) |>  -->\n<!--   dplyr::arrange(campeao) |> # <1> -->\n<!--   mutate(soma = dplyr::row_number()) -->\n<!-- ``` -->\n<!-- 1. Ordena a coluna `campeao`. Assim, valores `TRUE` aparecem primeiro -->\n\n<!-- Agora vamos plotar! -->\n\n<!-- ```{r} -->\n<!-- soma_pilotos |>  -->\n<!--   ggplot(aes(x = seasons, y = soma))+ -->\n<!--   geom_tile( -->\n<!--     aes(fill = dplyr::case_when(campeao == TRUE ~ \"campeão\", -->\n<!--                                 seasons == 2025 ~ \"atual\", -->\n<!--                                 TRUE ~ \"normal\")) -->\n<!--   )+ -->\n<!--   theme( -->\n<!--     legend.position = \"none\" -->\n<!--   ) -->\n<!-- ``` -->\n\n<!-- Perfeito! Agora vem a parte mais legal. Deixar o gráfico bonito! -->\n\n<!-- Vamos fazer uma checklist e ajustar tudo! -->\n\n<!-- - [ ] Gráfico clean (fundo branco, apenas eixo x, etc) -->\n<!-- - [ ] Eixo x de 10 em 10 anos -->\n<!-- - [ ] Sem espaço entre o gráfico e eixo x -->\n<!-- - [ ] Tamanho e cores dos retângulos -->\n<!-- - [ ] Gabriel Bortoleto destacado -->\n\n<!-- Começando pelo tema -->\n\n<!-- ```{r} -->\n<!-- soma_pilotos |>  -->\n<!--   ggplot(aes(x = seasons, y = soma))+ -->\n<!--   geom_tile( -->\n<!--     aes(fill = dplyr::case_when(campeao == TRUE ~ \"campeão\", -->\n<!--                                 seasons == 2025 ~ \"atual\", -->\n<!--                                 TRUE ~ \"normal\")) -->\n<!--   )+ -->\n<!--   theme_classic()+  # <1> -->\n<!--   theme( -->\n<!--     legend.position = \"none\",       # <2> -->\n<!--     axis.line.y = element_blank(),  # <3> -->\n<!--     axis.ticks.x = element_line(    # <4> -->\n<!--       lineend = \"round\",            # <4> -->\n<!--       color = \"black\"               # <4> -->\n<!--     ), -->\n<!--     axis.ticks.y = element_blank(), # <5> -->\n<!--     axis.title = element_blank(),   # <6> -->\n<!--     axis.text.y = element_blank(),  # <7> -->\n<!--     axis.text.x = element_text(     # <8> -->\n<!--       face = \"bold\",                # <8> -->\n<!--       color = \"black\"               # <8> -->\n<!--     ) -->\n<!--   ) -->\n<!-- ``` -->\n<!-- 1. `theme_classic()`: Remove as grades de fundo e simplifica o visual do gráfico. -->\n<!-- 2. `legend.position = \"none\"`: Esconde a legenda do gráfico. -->\n<!-- 3. `axis.line.y = element_blank()`: Remove a linha do eixo Y. -->\n<!-- 4. `axis.ticks.x`: Personaliza os ticks (marcas) do eixo X, deixando-os arredondados e pretos. -->\n<!-- 5. `axis.ticks.y = element_blank()`: Remove os ticks do eixo Y. -->\n<!-- 6. `axis.title = element_blank()`: Remove os títulos dos eixos. -->\n<!-- 7. `axis.text.y = element_blank()`: Esconde os rótulos do eixo Y. -->\n<!-- 8. `axis.text.x`: Deixa os rótulos do eixo X em negrito e pretos. -->\n\n<!-- ✅ Gráfico clean (fundo branco, apenas eixo x, etc) -->\n\n<!-- Agora os eixos -->\n\n<!-- ```{r} -->\n<!-- soma_pilotos |>  -->\n<!--   ggplot(aes(x = seasons, y = soma))+ -->\n<!--   geom_tile( -->\n<!--     aes(fill = dplyr::case_when(campeao == TRUE ~ \"campeão\", -->\n<!--                                 seasons == 2025 ~ \"atual\", -->\n<!--                                 TRUE ~ \"normal\")) -->\n<!--   )+ -->\n<!--   scale_x_continuous(             # <1> -->\n<!--     breaks = seq(1950, 2020, 10)  # <1> -->\n<!--   )+ -->\n<!--   scale_y_continuous(             # <2> -->\n<!--     expand = expansion(mult = c(0, 0.05))  # <2> -->\n<!--   )+ -->\n<!--   theme_classic()+ -->\n<!--   theme( -->\n<!--     legend.position = \"none\", -->\n<!--     axis.line.y = element_blank(), -->\n<!--     axis.ticks.x = element_line(lineend = \"round\", color = \"black\"), -->\n<!--     axis.ticks.y = element_blank(), -->\n<!--     axis.title = element_blank(), -->\n<!--     axis.text.y = element_blank(), -->\n<!--     axis.text.x = element_text(face = \"bold\", color = \"black\") -->\n<!--   ) -->\n<!-- ``` -->\n<!-- 1. Define os pontos de quebra (ticks) do eixo X a cada 10 anos, de 1950 a 2020. Isso deixa o eixo X mais organizado. -->\n<!-- 2. Ajusta o espaçamento do eixo Y a partir de uma multiplicação. O primeiro valor (0) remove espaço na parte inferior. O segundo valor (0.05) adiciona um pequeno espaço na parte superior (5%), evitando que os retângulos (*tiles*) fiquem colados à borda superior. -->\n\n<!-- ✅ Eixo x de 10 em 10 anos -->\n\n<!-- ✅ Sem espaço entre o gráfico e eixo x -->\n\n<!-- Falta ainda ajustarmos os retângulos -->\n\n<!-- ```{r} -->\n<!-- soma_pilotos |>  -->\n<!--   ggplot(aes(x = seasons, y = soma))+ -->\n<!--   geom_tile( -->\n<!--     aes(fill = dplyr::case_when(campeao == TRUE ~ \"campeão\", -->\n<!--                                 seasons == 2025 ~ \"atual\", -->\n<!--                                 TRUE ~ \"normal\"), -->\n<!--         linewidth = ifelse(driver == \"Gabriel Bortoleto\", 0.3, NA) # <1> -->\n<!--     ), -->\n<!--     color = \"black\",     # <2> -->\n<!--     width = 0.8,         # <3> -->\n<!--     height = 0.8         # <3> -->\n<!--   )+ -->\n<!--   scale_x_continuous( -->\n<!--     breaks = seq(1950, 2020, 10) -->\n<!--   )+ -->\n<!--   scale_y_continuous( -->\n<!--     expand = expansion(mult = c(0, 0.05)) -->\n<!--   )+ -->\n<!--   scale_linewidth_identity() + # <4> -->\n<!--   scale_fill_manual(           # <5> -->\n<!--     values = c( -->\n<!--       \"campeão\" = \"#ffce2e\", -->\n<!--       \"normal\" = \"#ff7b80\", -->\n<!--       \"atual\" = \"#a8a8a8\" -->\n<!--     ) -->\n<!--   )+ -->\n<!--   theme_classic()+ -->\n<!--   theme( -->\n<!--     legend.position = \"none\", -->\n<!--     axis.line.y = element_blank(), -->\n<!--     axis.ticks.x = element_line(lineend = \"round\", color = \"black\"), -->\n<!--     axis.ticks.y = element_blank(), -->\n<!--     axis.title = element_blank(), -->\n<!--     axis.text.y = element_blank(), -->\n<!--     axis.text.x = element_text(face = \"bold\", color = \"black\"), -->\n<!--     plot.background = element_rect(fill = NA, color = NA), -->\n<!--     panel.background = element_rect(fill = NA, color = NA) -->\n<!--   ) -->\n<!-- ``` -->\n<!-- 1. Define `linewidth`, para que o retângulo (*tile*) do Gabriel Bortoleto tenha uma borda mais espessa (0.3), enquanto os demais têm borda invisível (NA). -->\n<!-- 2. Define `color = \"black\"` para que as bordas dos tiles fiquem pretas (quando hourve borda). -->\n<!-- 3. Controla o tamanho dos tiles com `width = 0.8`, `height = 0.8`, reduzindo ligeiramente o tamanho para criar uma separação entre os blocos. -->\n<!-- 4. Usa `scale_linewidth_identity()` para interpretar os valores de *linewidth* diretamente, sem precisar de uma escala mapeada. -->\n<!-- 5. Define `scale_fill_manual(values = c(...))` para atribuir cores personalizadas aos tiles: campeões em amarelo, normais em vermelho e a temporada atual em cinza. -->\n\n<!-- Agora sim! Aprendemos como uma equipe de jornal chegou até este gráfico! -->\n\n<!-- Espero que este post tenha sido útil para você! Se tiver alguma dúvida, sugestão ou crítica, [mande um e-mail](mailto:bhmstabile@gmail.com)! -->\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}