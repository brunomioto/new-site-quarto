{
  "hash": "f4c14b7a07fba2dd09a0b7443fe9ab5d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Decifrando gráficos #1\"\ndescription: \"Do Jornal para o R\"\nauthor: \"Bruno Mioto\"\ndate: \"2025-03-17\"\nimage: cover.png\ncategories: [\"tutorial\",\"dataviz\",\"ggplot2\"]\nopen-graph:\n  description: \"Do Jornal para o R\"\n  image: cover.png\ntwitter-card:\n  description: \"Do Jornal para o R\"\n  image: cover.png\n  card-style: summary_large_image\nformat:\n  html:\n    code-link: true\n    fig-width: 5\n    fig-height: 2\n    fig-dpi: 600\nexecute:\n  warning: false\n---\n\n\n\n![](cover.png)\n\n## Como isso foi feito?\n\nTodo dia vemos gráficos nos jornais, mas nem sempre sabemos como eles foram feitos. De onde vieram os **dados**? Como foram **tratados**? E será que dá para **recriá-los** usando o R?\n\nNesta série, vou pegar gráficos publicados nos principais **jornais** e recriá-los do zero usando **R, tidyverse e ggplot2**. Vou mostrar como encontrar os dados, organizá-los e gerar visualizações que chegam o mais próximo possível do original – tudo de forma transparente e didática. Sim! Vamos fazer e aprender juntos!\n\nE tem mais: **todo o código e dados utilizados estarão disponíveis e comentados (clique nos números abaixo de cada conjunto de código!)**. E por estarmos trabalhando com uma **linguagem de programação**, todos vão obter o mesmo resultado ao final do script.\n\nAcompanhe a série e veja como transformar dados brutos em visualizações incríveis!\n\n## #1 - Pilotos brasileiros na F1 (Nexo Jornal)\n\nVamos começar com um gráfico publicado recentemente pelo **Nexo Jornal**: [O número de brasileiros na Fórmula 1 ao longo dos anos](https://www.nexojornal.com.br/grafico/2025/03/14/formula-1-pilotos-brasileiros-historico)\n\n![](./figures/grafico_nexo.png)\n\nA equipe do Nexo é muito gente boa e sempre busca explicar melhor como é o trabalho deles, que você pode conferir na série de posts [Nos Eixos](https://www.nexojornal.com.br/grafico/2024/03/08/grafico-e-infografico-como-faz-nexo-jornal). Eles utilizam o R para trabalhar com os dados e gerar os gráficos, e o Illustrator para retoques finais.\n\nComo ficaremos apenas no R, vamos focar na construção do gráfico em si (retângulos/tiles e eixo), sem as ilustrações no entorno.\n\n### Obtendo os dados\n\nSegundo a fonte do gráfico, os dados foram obtidos pela plataforma Kaggle (utilizada para competições de Big Data), e podemos ver neste link: [Kaggle](https://www.kaggle.com/datasets/petalme/f1-drivers-dataset)\n\nPrimeiro vamos carregar os pacotes necessários\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr) #baixar dados csv\nlibrary(janitor) #limpeza dos dados\nlibrary(dplyr) #manipulação dos dados\nlibrary(tidyr) #tratamento dos dados\nlibrary(stringr) #trabalhar com strings/texto\nlibrary(ggplot2) #gráficos\n```\n:::\n\n\n\nAgora vamos baixar a tabela disponibilizado no site e salvar com o nome `F1Drivers_Dataset.csv` dentro de uma pasta chamada `data`. Pronto, agora podemos importar os dados.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npilotos <- readr::read_csv(\"data/F1Drivers_Dataset.csv\")\n```\n:::\n\n\n\nCaramba! São **868 pilotos e 22 variáveis**!\n\n### Trabalhando com os dados\n\nMas veja que os nomes das variáveis tem letras maiúsculas e espaços (Championship Years). Vamos padronizar para `snake_case`com o pacote {janitor}. Vamos salvar cada passo em um novo objeto para ficar mais fácil de acompanhar.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npilotos_clean <- janitor::clean_names(pilotos)\n```\n:::\n\n\n\nVamos filtrar apenas os brasileiros e analisar este dataset\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npilotos_br <- pilotos_clean |> \n  dplyr::filter(nationality == \"Brazil\")\n\npilotos_br\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 32 × 22\n   driver             nationality seasons championships race_entries race_starts\n   <chr>              <chr>       <chr>           <dbl>        <dbl>       <dbl>\n 1 Rubens Barrichello Brazil      [1993,…             0          326         322\n 2 Enrique Bernoldi   Brazil      [2001,…             0           29          28\n 3 Gino Bianco        Brazil      [1952]              0            4           4\n 4 Raul Boesel        Brazil      [1982,…             0           30          23\n 5 Luiz Bueno         Brazil      [1973]              0            1           1\n 6 Luciano Burti      Brazil      [2000,…             0           15          14\n 7 Pedro Diniz        Brazil      [1995,…             0           99          98\n 8 Christian Fittipa… Brazil      [1992,…             0           43          40\n 9 Emerson Fittipaldi Brazil      [1970,…             2          149         144\n10 Pietro Fittipaldi  Brazil      [2020]              0            2           2\n# ℹ 22 more rows\n# ℹ 16 more variables: pole_positions <dbl>, race_wins <dbl>, podiums <dbl>,\n#   fastest_laps <dbl>, points <dbl>, active <lgl>, championship_years <chr>,\n#   decade <dbl>, pole_rate <dbl>, start_rate <dbl>, win_rate <dbl>,\n#   podium_rate <dbl>, fast_lap_rate <dbl>, points_per_entry <dbl>,\n#   years_active <dbl>, champion <lgl>\n```\n\n\n:::\n:::\n\n\n\nNeste dataset não temos o **Gabriel Bortoleto** que vai representar o Brasil em 2025. Vamos adicioná-lo com `dplyr::add_row()` e apenas as variáveis que vamos precisar.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npilotos_br2 <- pilotos_br |> \n  dplyr::add_row(\n    driver = \"Gabriel Bortoleto\",\n    nationality = \"Brazil\",\n    seasons = \"[2025]\"\n  )\n```\n:::\n\n\n\nSão **33 pilotos brasileiros**, aí no meio devem estar os campeões **Emerson Fittipaldi, Nelson Piquet e Ayrton Senna**. Já já vamos chegar lá!\n\nAgora vamos criar 2 datasets, um para todas as temporadas de todos os pilotos, e outro para as temporadas em que algum foi campeão.\n\nPara o primeiro, vamos selecionar as colunas necessárias e salvar em `pilotos_br3`\n\n- `driver` (Nome do piloto)\n- `nationality` (Nacionalidade)\n- `seasons` (Temporadas)\n- `championship_years` (Anos em que foi campeão)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npilotos_br3 <- pilotos_br2 |> \n  dplyr::select(driver, nationality, seasons,\n                championship_years)\n```\n:::\n\n\n\nMas veja que precisamos quebrar a coluna `seasons` para cada valor ficar em uma linha, obtendo um formato **tidy**, que utilizaremos no **ggplot2** mais pra frente. Para isso vamos usar a função `tidyr::separate_longer_delim()` que nos permite separar uma string por algum delimitador (nesse caso `, `). E vamos também remover os colchetes `[` ou `]` que ficarem perdidos utilizando o pacote {stringr} e transformar essa variável em numérica.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npilotos_br4 <- pilotos_br3 |> \n  tidyr::separate_longer_delim( # <1>\n    cols = c(seasons), # <1>\n    delim = \", \") |>  # <1>\n  dplyr::mutate( # <2>\n    seasons = stringr::str_remove_all(seasons, \"\\\\[|\\\\]\"), # <2>\n    seasons = as.numeric(seasons) # <2>\n    )  # <2>\n```\n:::\n\n\n1. Separa os valores na coluna `seasons` em múltiplas linhas, usando a vírgula seguida de espaço como delimitador.\n2. Remove os colchetes `[` ou `]` e transforma a variável `seasons` em numérica.\n\nAgora vamos utilizar este dataset para criar o `pilotos_campeoes`. Vamos usar novamente o `tidyr::separate_longer_delim()`, mas dessa vez com a variável `championship_years`.\nIsso vai gerar linhas duplicadas, pois a função busca criar todas combinações entre as linhas. Como aqui queremos apenas os campeões nos respectivos anos, vamos filtrar as temporadas (`seasons`) que são iguais às temporadas vitoriosas (`championship_years`).\nPor fim, vamos criar uma coluna dizendo que eles foram campeões neste ano\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npilotos_campeoes <- pilotos_br4 |>\n  tidyr::separate_longer_delim( # <1>\n    cols = c(championship_years), # <1>\n    delim = \", \") |> # <1>\n  dplyr::mutate( # <2>\n    championship_years = stringr::str_remove_all( # <2>\n      championship_years, # <2>\n      \"\\\\[|\\\\]\")) |> # <2>\n  filter(seasons == championship_years) |>  # <3>\n  mutate( # <4>\n    campeao = TRUE # <4>\n  ) # <4>\n```\n:::\n\n\n1. Separa os valores na coluna `championship_years` em múltiplas linhas, usando a vírgula seguida de espaço como delimitador.\n2. Remove os colchetes `[` ou `]` e transforma a variável `seasons` em numérica.\n3. Filtra `seasons` iguais à `championship_years`.\n4. Cria uma coluna `campeao` com valor `TRUE` para estes pilotos.\n\nAgora só precisamos combinar o dataset `pilotos_campeoes` com o `pilotos_br4` utilizando o `left_join()`. Aqui vamos falar para utilizar as colunas `driver` e `seasons` como guias do **join**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npilotos_br5 <- pilotos_br4 |> \n  dplyr::left_join(\n    pilotos_campeoes,\n    by = c(\"driver\", \"seasons\") # <2>\n    )\n```\n:::\n\n\n1. Define quais variávels serão combinadas de ambos os datasets.\n\nPronto! Temos toda a informação que precisamos. Vamos aos gráficos!\n\n### Criando o gráfico\n\nLogo de cara, vemos que o gráfico do **Nexo** é um *tile plot*, em que utilizamos a função `geom_tile()`.\n\nPara isso, precisamos contar o número de pilotos em cada ano, já que o eixo Y apresenta a soma de pilotos. Para isso podemos agrupar nosso dataset por temporada (`group_by()`) e contar o numero de linhas/pilotos (`row_number()`)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoma_pilotos <- pilotos_br5 |> \n  dplyr::group_by(seasons) |> # <1>\n  dplyr::mutate(soma = dplyr::row_number()) # <2>\n```\n:::\n\n\n1. Agrupa os dados por temporada (`seasons`) \n2. Conta o número de linhas (nesse caso, pilotos) em cada grupo\n\nAgora vamos plotar! Lembre-se que precisamos utilizar cores de preenchimento diferentes para campeões e também para a temporada atual!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoma_pilotos |>                            # <1>\n  ggplot(aes(x = seasons, y = soma))+      # <2>\n  geom_tile(                                # <3>\n    aes(fill = dplyr::case_when(            # <4>\n      campeao == TRUE ~ \"campeão\",          # <4>\n      seasons == 2025 ~ \"atual\",            # <4>\n      TRUE ~ \"normal\"                        # <4>\n    ))                                      # <4>\n  )+                                        # <3>\n  theme(                                     # <5>\n    legend.position = \"none\"                 # <5>\n  )                                          # <5>\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=3000}\n:::\n:::\n\n\n1. Pegamos `soma_pilotos` e passamos adiante com o pipe.\n2. Criamos um gráfico com `ggplot()`, onde `seasons` define o eixo X e `soma` define o eixo Y.\n3. Adicionamos `geom_tile()`, que cria um mosaico de retângulos para representar os valores.\n4. Definimos a cor de preenchimento com `case_when()`, categorizando os tiles como \"campeão\", \"atual\" ou \"normal\".\n5. Ajustamos o tema para remover a legenda `(legend.position = \"none\")`, deixando o gráfico mais limpo.\n\nQuase! Veja que os campeões não estão na base, como na figura original. Para isso precisamos ordenar (`arrange()`) o dataset para que os campeões apareçam primeiro na contagem de linhas. Vamos tentar novamente!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoma_pilotos <- pilotos_br5 |> \n  dplyr::group_by(seasons) |> \n  dplyr::arrange(campeao) |> # <1>\n  mutate(soma = dplyr::row_number())\n```\n:::\n\n\n1. Ordena a coluna `campeao`. Assim, valores `TRUE` aparecem primeiro\n\nAgora vamos plotar!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoma_pilotos |> \n  ggplot(aes(x = seasons, y = soma))+\n  geom_tile(\n    aes(fill = dplyr::case_when(campeao == TRUE ~ \"campeão\",\n                                seasons == 2025 ~ \"atual\",\n                                TRUE ~ \"normal\"))\n  )+\n  theme(\n    legend.position = \"none\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=3000}\n:::\n:::\n\n\n\nPerfeito! Agora vem a parte mais legal. Deixar o gráfico bonito!\n\nVamos fazer uma checklist e ajustar tudo!\n\n- [ ] Gráfico clean (fundo branco, apenas eixo x, etc)\n- [ ] Eixo x de 10 em 10 anos\n- [ ] Sem espaço entre o gráfico e eixo x\n- [ ] Tamanho e cores dos retângulos\n- [ ] Gabriel Bortoleto destacado\n\nComeçando pelo tema\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoma_pilotos |> \n  ggplot(aes(x = seasons, y = soma))+\n  geom_tile(\n    aes(fill = dplyr::case_when(campeao == TRUE ~ \"campeão\",\n                                seasons == 2025 ~ \"atual\",\n                                TRUE ~ \"normal\"))\n  )+\n  theme_classic()+  # <1>\n  theme(\n    legend.position = \"none\",       # <2>\n    axis.line.y = element_blank(),  # <3>\n    axis.ticks.x = element_line(    # <4>\n      lineend = \"round\",            # <4>\n      color = \"black\"               # <4>\n    ),\n    axis.ticks.y = element_blank(), # <5>\n    axis.title = element_blank(),   # <6>\n    axis.text.y = element_blank(),  # <7>\n    axis.text.x = element_text(     # <8>\n      face = \"bold\",                # <8>\n      color = \"black\"               # <8>\n    )\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=3000}\n:::\n:::\n\n\n1. `theme_classic()`: Remove as grades de fundo e simplifica o visual do gráfico.\n2. `legend.position = \"none\"`: Esconde a legenda do gráfico.\n3. `axis.line.y = element_blank()`: Remove a linha do eixo Y.\n4. `axis.ticks.x`: Personaliza os ticks (marcas) do eixo X, deixando-os arredondados e pretos.\n5. `axis.ticks.y = element_blank()`: Remove os ticks do eixo Y.\n6. `axis.title = element_blank()`: Remove os títulos dos eixos.\n7. `axis.text.y = element_blank()`: Esconde os rótulos do eixo Y.\n8. `axis.text.x`: Deixa os rótulos do eixo X em negrito e pretos.\n\n✅ Gráfico clean (fundo branco, apenas eixo x, etc)\n\nAgora os eixos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoma_pilotos |> \n  ggplot(aes(x = seasons, y = soma))+\n  geom_tile(\n    aes(fill = dplyr::case_when(campeao == TRUE ~ \"campeão\",\n                                seasons == 2025 ~ \"atual\",\n                                TRUE ~ \"normal\"))\n  )+\n  scale_x_continuous(             # <1>\n    breaks = seq(1950, 2020, 10)  # <1>\n  )+\n  scale_y_continuous(             # <2>\n    expand = expansion(mult = c(0, 0.05))  # <2>\n  )+\n  theme_classic()+\n  theme(\n    legend.position = \"none\",\n    axis.line.y = element_blank(),\n    axis.ticks.x = element_line(lineend = \"round\", color = \"black\"),\n    axis.ticks.y = element_blank(),\n    axis.title = element_blank(),\n    axis.text.y = element_blank(),\n    axis.text.x = element_text(face = \"bold\", color = \"black\")\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=3000}\n:::\n:::\n\n\n1. Define os pontos de quebra (ticks) do eixo X a cada 10 anos, de 1950 a 2020. Isso deixa o eixo X mais organizado.\n2. Ajusta o espaçamento do eixo Y a partir de uma multiplicação. O primeiro valor (0) remove espaço na parte inferior. O segundo valor (0.05) adiciona um pequeno espaço na parte superior (5%), evitando que os retângulos (*tiles*) fiquem colados à borda superior.\n\n✅ Eixo x de 10 em 10 anos\n\n✅ Sem espaço entre o gráfico e eixo x\n\nFalta ainda ajustarmos os retângulos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoma_pilotos |> \n  ggplot(aes(x = seasons, y = soma))+\n  geom_tile(\n    aes(fill = dplyr::case_when(campeao == TRUE ~ \"campeão\",\n                                seasons == 2025 ~ \"atual\",\n                                TRUE ~ \"normal\"),\n        linewidth = ifelse(driver == \"Gabriel Bortoleto\", 0.3, NA) # <1>\n    ),\n    color = \"black\",     # <2>\n    width = 0.8,         # <3>\n    height = 0.8         # <3>\n  )+\n  scale_x_continuous(\n    breaks = seq(1950, 2020, 10)\n  )+\n  scale_y_continuous(\n    expand = expansion(mult = c(0, 0.05))\n  )+\n  scale_linewidth_identity() + # <4>\n  scale_fill_manual(           # <5>\n    values = c(\n      \"campeão\" = \"#ffce2e\",\n      \"normal\" = \"#ff7b80\",\n      \"atual\" = \"#a8a8a8\"\n    )\n  )+\n  theme_classic()+\n  theme(\n    legend.position = \"none\",\n    axis.line.y = element_blank(),\n    axis.ticks.x = element_line(lineend = \"round\", color = \"black\"),\n    axis.ticks.y = element_blank(),\n    axis.title = element_blank(),\n    axis.text.y = element_blank(),\n    axis.text.x = element_text(face = \"bold\", color = \"black\"),\n    plot.background = element_rect(fill = NA, color = NA),\n    panel.background = element_rect(fill = NA, color = NA)\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=3000}\n:::\n:::\n\n\n1. Define `linewidth`, para que o retângulo (*tile*) do Gabriel Bortoleto tenha uma borda mais espessa (0.3), enquanto os demais têm borda invisível (NA).\n2. Define `color = \"black\"` para que as bordas dos tiles fiquem pretas (quando hourve borda).\n3. Controla o tamanho dos tiles com `width = 0.8`, `height = 0.8`, reduzindo ligeiramente o tamanho para criar uma separação entre os blocos.\n4. Usa `scale_linewidth_identity()` para interpretar os valores de *linewidth* diretamente, sem precisar de uma escala mapeada.\n5. Define `scale_fill_manual(values = c(...))` para atribuir cores personalizadas aos tiles: campeões em amarelo, normais em vermelho e a temporada atual em cinza.\n\nAgora sim! Aprendemos como uma equipe de jornal chegou até este gráfico!\n\nEspero que este post tenha sido útil para você! Se tiver alguma dúvida, sugestão ou crítica, [mande um e-mail](mailto:bhmstabile@gmail.com)!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}